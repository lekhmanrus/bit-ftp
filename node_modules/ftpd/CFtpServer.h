#ifndef CFTPSERVER_H
#define CFTPSERVER_H
#define _CRT_SECURE_NO_DEPRECATE
#define CFTPSERVER_ENABLE_EVENTS

#include <ctime>
#include <cctype>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <fcntl.h>
#include <stdarg.h>
#include <sys/stat.h>

#ifdef CFTPSERVER_CONFIG_H_PATH
	#include CFTPSERVER_CONFIG_H_PATH
#endif

#ifndef WIN32
	#ifdef __ECOS
		#define USE_BSDSOCKETS
		#define SOCKET int
	#else
		typedef int SOCKET;
	#endif
	#if defined(__CYGWIN__) || defined(__OpenBSD__) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__DragonFly__)
		#define __USE_FILE_OFFSET64
	#endif
	typedef long long __int64;
	#define MAX_PATH PATH_MAX
	#include <limits.h>
	#include <dirent.h>
	#include <pthread.h>
	#include <sys/socket.h>
	#include <netinet/in_systm.h>
	#include <netinet/in.h>
	#include <netinet/ip.h>
	#include <sys/select.h>
	#include <arpa/inet.h>
	#include <errno.h>
	#include <unistd.h>
#else
	#ifdef _MSC_VER
		#pragma comment(lib,"ws2_32.lib")
	#endif
	#define WIN32_LEAN_AND_MEAN
	#include <io.h>
	#include <direct.h>
	#include <winsock2.h>
	#include <process.h>
#endif

#ifndef INADDR_NONE
	#define INADDR_NONE	((unsigned long int) 0xffffffff)
#endif
#ifndef INADDR_ANY
	#define INADDR_ANY	((unsigned long int) 0x00000000)
#endif

class CFtpServer {
public:
	CFtpServer();
	~CFtpServer();

	class CUserEntry;
	class CClientEntry;
	friend class CUserEntry;
	friend class CClientEntry;

	bool StartListening( unsigned long ulAddr, unsigned short int usPort );
	bool StopListening();
	bool StopAccepting();
	bool IsListening() const { return bIsListening; }
	bool StartAccepting();
	bool IsAccepting() const { return bIsAccepting; }
	unsigned short GetListeningPort() const { return usListeningPort; }
	bool SetDataPortRange( unsigned short int usStart, unsigned short int uiLen );
	bool GetDataPortRange( unsigned short int *usStart, unsigned short int *usLen );
	void SetNoLoginTimeout( unsigned long int ulSecond ) { ulNoLoginTimeout = ulSecond; }
	unsigned long int GetNoLoginTimeout() const { return ulNoLoginTimeout; }
	void SetNoTransferTimeout( unsigned long int ulSecond ) { ulNoTransferTimeout = ulSecond; }
	unsigned long int GetNoTransferTimeout() const { return ulNoTransferTimeout; }
	void SetCheckPassDelay( unsigned int ulMilliSecond ) { uiCheckPassDelay = ulMilliSecond; }
	unsigned int GetCheckPassDelay() const { return uiCheckPassDelay; }
	void SetMaxPasswordTries( unsigned int uiMaxPassTries ) { uiMaxPasswordTries = uiMaxPassTries; }
	unsigned int GetMaxPasswordTries() const { return uiMaxPasswordTries; }
	void SetTransferBufferSize( unsigned int uiSize ) { uiTransferBufferSize = uiSize; }
	unsigned int GetTransferBufferSize() const { return uiTransferBufferSize; }
	void SetTransferSocketBufferSize( unsigned int uiSize ) { uiTransferSocketBufferSize = uiSize; }
	unsigned int GetTransferSocketBufferSize() const { return uiTransferSocketBufferSize; }
	unsigned int GetNbClient() const { return uiNumberOfClient; }
	unsigned int GetNbUser() const { return uiNumberOfUser; }
	enum eEvents {
		// User events
		NEW_USER,
		DELETE_USER,
		// Client events
		NEW_CLIENT,
		DELETE_CLIENT,
		CLIENT_DISCONNECT,
		CLIENT_AUTH,
		CLIENT_UPLOAD,
		CLIENT_DOWNLOAD,
		CLIENT_LIST,
		CLIENT_CHANGE_DIR,
		RECVD_CMD_LINE,
		SEND_REPLY,
		TOO_MANY_PASS_TRIES,
		NO_LOGIN_TIMEOUT,
		NO_TRANSFER_TIMEOUT,
		CLIENT_SOCK_ERROR,
		CLIENT_SOFTWARE,
		// Server event
		START_LISTENING,
		STOP_LISTENING,
		START_ACCEPTING,
		STOP_ACCEPTING,
		MEM_ERROR,
		THREAD_ERROR
	};

	#ifdef CFTPSERVER_ENABLE_EVENTS
		typedef void (*OnServerEventCallback_t) ( int Event );
		typedef void (*OnUserEventCallback_t) ( int Event, CFtpServer::CUserEntry *pUser, void *pArg );
		typedef void (*OnClientEventCallback_t) ( int Event, CFtpServer::CClientEntry *pClient, void *pArg );
		void SetServerCallback( OnServerEventCallback_t pCallback )
			{ _OnServerEventCb = pCallback; }
		void SetUserCallback( OnUserEventCallback_t pCallback )
			{ _OnUserEventCb = pCallback; }
		void SetClientCallback( OnClientEventCallback_t pCallback )
			{ _OnClientEventCb = pCallback; }
		void OnServerEventCb( int Event )
			{ if( _OnServerEventCb ) _OnServerEventCb( Event ); }
		void OnUserEventCb( int Event, CFtpServer::CUserEntry *pUser, void *pArg = NULL )
			{ if( _OnUserEventCb ) _OnUserEventCb( Event, pUser, pArg ); }
		void OnClientEventCb( int Event, CFtpServer::CClientEntry *pClient, void *pArg = NULL )
			{ if( _OnClientEventCb ) _OnClientEventCb( Event, pClient, pArg ); }
	#else
		void OnServerEventCb( int Event ) const {}
		void OnUserEventCb( int Event, CFtpServer::CUserEntry *pUser, void *pArg = NULL ) const {}
		void OnClientEventCb( int Event, CFtpServer::CClientEntry *pClient, void *pArg = NULL ) const {}
	#endif

	enum
	{
		READFILE	= 0x1,
		WRITEFILE	= 0x2,
		DELETEFILE	= 0x4,
		LIST		= 0x8,
		CREATEDIR	= 0x10,
		DELETEDIR	= 0x20
	};

	CUserEntry *AddUser( const char *pszLogin, const char *pszPass, const char *pszStartDir );
	bool DeleteUser( CFtpServer::CUserEntry *pUser );

private:
	class CEnumFileInfo;
	class CCriticialSection;
	#ifdef CFTPSERVER_ENABLE_EVENTS
		OnServerEventCallback_t _OnServerEventCb;
		OnUserEventCallback_t _OnUserEventCb;
		OnClientEventCallback_t _OnClientEventCb;
	#endif

	class CCriticialSection	{
	public:
		bool Initialize() {
			#ifdef WIN32
				InitializeCriticalSection( &m_CS );
			#else
				pthread_mutex_init( &m_CS, NULL );
			#endif
			return true;
		}
		bool Enter() {
			#ifdef WIN32
				EnterCriticalSection( &m_CS );
			#else
				pthread_mutex_lock( &m_CS );
			#endif
			return true;
		}
		bool Leave() {
			#ifdef WIN32
				LeaveCriticalSection( &m_CS );
			#else
				pthread_mutex_unlock( &m_CS );
			#endif
			return true;
		}
		bool Destroy() {
			#ifdef WIN32
				DeleteCriticalSection( &m_CS );
			#else
				pthread_mutex_destroy( &m_CS );
			#endif
			return true;
		}

	private:
		#ifdef WIN32
			CRITICAL_SECTION m_CS;
		#else
			pthread_mutex_t m_CS;
		#endif
	} FtpServerLock;

	enum {
		MaxLoginLen = 16,
		MaxPasswordLen = 16,
		MaxRootPathLen = MAX_PATH
	};

	class CCriticialSection UserListLock;
	class CUserEntry *pFirstUser, *pLastUser;

	CUserEntry *SearchUserFromLogin( const char *pszName );

	CFtpServer::CClientEntry *AddClient( SOCKET Sock, struct sockaddr_in *Sin );

	class CCriticialSection ClientListLock;
	class CClientEntry *pFirstClient,
										 *pLastClient;
	volatile SOCKET ListeningSock;
	struct {
		unsigned short int usLen,
											 usStart;
	} DataPortRange;

	bool bIsListening;
	bool bIsAccepting;
	unsigned short int usListeningPort;

	#ifdef WIN32
		HANDLE hAcceptingThread;
		unsigned uAcceptingThreadID;
		static unsigned __stdcall StartAcceptingEx( void *pvParam );
	#else
		pthread_t AcceptingThreadID;
		static void *StartAcceptingEx( void *pvParam );
		pthread_attr_t m_pattrServer;
		pthread_attr_t m_pattrClient;
		pthread_attr_t m_pattrTransfer;
	#endif

	static bool SimplifyPath( char *pszPath );
	unsigned int uiNumberOfUser;
	unsigned int uiNumberOfClient;

	unsigned int uiMaxPasswordTries;
	unsigned int uiCheckPassDelay;
	unsigned long int ulNoTransferTimeout, ulNoLoginTimeout;
	unsigned int uiTransferBufferSize, uiTransferSocketBufferSize;
};

class CFtpServer::CUserEntry {
public:
	CUserEntry();
	~CUserEntry() {}

	friend class CFtpServer;
	friend class CFtpServer::CClientEntry;

	bool SetPrivileges( unsigned char ucPriv );
	unsigned char GetPrivileges() const { return ucPrivileges; }
	unsigned int GetNumberOfClient() const { return uiNumberOfClient; }
	void SetMaxNumberOfClient( unsigned int uiMax ) { uiMaxNumberOfClient = uiMax; }
	unsigned int GetMaxClient() const { return uiMaxNumberOfClient; }
	void SetLogin( const char *pszLogin ) { strcpy( szLogin, pszLogin ); }
	const char *GetLogin() const { return szLogin; }
	void SetPassword( const char *pszPass ) { strcpy( szPassword, pszPass ); }
	const char *GetPassword() const { return szPassword; }
	bool SetStartDirectory( const char *pszStartDir );
	const char *GetStartDirectory() const { return szStartDirectory; }

private:
	class CUserEntry *pPrevUser, *pNextUser;
	bool bDelete;
	bool bIsEnabled;
	CFtpServer *pFtpServer;
	unsigned char ucPrivileges;
	char szLogin[ MaxLoginLen + 1 ];
	char szPassword[ MaxPasswordLen + 1 ];
	char szStartDirectory[ MaxRootPathLen + 1 ];
	unsigned int uiNumberOfClient, uiMaxNumberOfClient;
};

class CFtpServer::CClientEntry {
public:

	CClientEntry();
	~CClientEntry();

	friend class CFtpServer;
	struct in_addr *GetIP() const { return (struct in_addr*)&ulClientIP; }
	struct in_addr *GetServerIP() const { return (struct in_addr*)&ulServerIP; }
	bool IsLogged() const { return bIsLogged; }
	bool CheckPrivileges( unsigned char ucPriv ) const;
	CUserEntry *GetUser() const { return ( bIsLogged ? pUser : NULL ); }
	char *GetWorkingDirectory() { return szWorkingDir; }
	bool InitDelete();

private:
	volatile SOCKET CtrlSock;
	bool bIsLogged;
	
	void LogIn();
	void LogOut();
	void ResetTimeout() { time( &tTimeoutTime ); }

	enum Status_t {
		WAITING,
		LISTING,
		UPLOADING,
		DOWNLOADING
	} volatile eStatus;
	unsigned long ulDataIp;
	unsigned short usDataPort;
	char szWorkingDir[ MAX_PATH + 3 + 1 ];
	char szRenameFromPath[ MAX_PATH + 1 ];
	time_t tTimeoutTime;
	enum {
		MAX_COMMAND_LINE_LEN = MAX_PATH + 32
	};
	char sCmdBuffer[ MAX_COMMAND_LINE_LEN + 1 ];
	char *pszCmdArg;
	char *psNextCmd;
	int iCmdLen;
	int iCmdRecvdLen;
	int nRemainingCharToParse;

	int ParseLine();
	bool ReceiveLine();

	unsigned int nPasswordTries;

	class CCriticialSection ClientLock;

	#ifdef WIN32
		HANDLE hClientThread;
		unsigned uClientThreadID;
		static unsigned __stdcall Shell( void *pvParam );
	#else
		pthread_t ClientThreadID;
		static void* Shell( void *pvParam );
	#endif

	enum
	{
		CMD_NONE = -1,
		CMD_QUIT,
		CMD_USER,
		CMD_PASS,
		CMD_NOOP,
		CMD_ALLO,
		CMD_HELP,
		CMD_SYST,
		CMD_STRU,
		CMD_MODE,
		CMD_TYPE,
		CMD_CLNT,
		CMD_PORT,
		CMD_PASV,
		CMD_LIST,
		CMD_NLST,
		CMD_CWD,
		CMD_XCWD,
		CMD_FEAT,
		CMD_MDTM,
		CMD_PWD,
		CMD_XPWD,
		CMD_CDUP,
		CMD_XCUP,
		CMD_STAT,
		CMD_ABOR,
		CMD_REST,
		CMD_RETR,
		CMD_STOR,
		CMD_APPE,
		CMD_STOU,
		CMD_SIZE,
		CMD_DELE,
		CMD_RNFR,
		CMD_RNTO,
		CMD_MKD,
		CMD_XMKD,
		CMD_RMD,
		CMD_XRMD,
		CMD_OPTS
	};

	volatile SOCKET DataSock;

	enum DataMode_t {
		STREAM
	} eDataMode;
	enum DataType_t {
		ASCII,
		BINARY, ///< equals to IMAGE
		EBCDIC
	} eDataType;
	enum DataConnection_t {
		NONE,
		PASV,
		PORT
	} eDataConnection;
	struct DataTransfer_t
	{
		CFtpServer::CClientEntry *pClient;
		#ifdef __USE_FILE_OFFSET64
			__int64 RestartAt;
			#ifdef WIN32
				struct _stati64 st;
			#else
				struct stat st;
			#endif
		#else
			int RestartAt;
			#ifdef WIN32
				struct _stat st;
			#else
				struct stat st;
			#endif
		#endif

		int nCmd;
		SOCKET SockList;
		bool opt_a, opt_d, opt_F, opt_l;
		DataMode_t eDataMode;
		DataType_t eDataType;

		char szPath[ MAX_PATH + 1 ];
		#ifdef WIN32
			HANDLE hTransferThread;
			unsigned uTransferThreadID;
		#else
			pthread_t TransferThreadID;
		#endif
	} CurrentTransfer;

	bool OpenDataConnection( int nCmd ); ///< Open the Data Channel in order to transmit data.
	bool ResetDataConnection( bool bSyncWait = true ); ///< Close the Data Channel.

	#ifdef WIN32
		static unsigned __stdcall RetrieveThread( void *pvParam );
		static unsigned __stdcall StoreThread( void *pvParam  );
		static unsigned __stdcall ListThread( void *pvParam );
	#else
		static void* RetrieveThread( void *pvParem);
		static void* StoreThread( void *pvParam );
		static void* ListThread( void *pvParam );
	#endif

	bool SafeWrite( int hFile, char *pBuffer, int nLen );
	char* BuildPath( char* szAskedPath, char **pszVirtualPath = NULL );
	char* BuildVirtualPath( char* szAskedPath );
	int GetFileListLine( char* psLine, unsigned short mode,
	#ifdef __USE_FILE_OFFSET64
		__int64 size,
	#else
		long size,
	#endif
	time_t mtime, const char* pszName, bool opt_F );
	bool AddToListBuffer( DataTransfer_t *pTransfer,
		char *pszListLine, int nLineLen,
		char *pBuffer, unsigned int *nBufferPos, unsigned int uiBufferSize );

	CFtpServer::CUserEntry *pUser;
	class CClientEntry *pPrevClient, *pNextClient;

	unsigned long ulServerIP;
	unsigned long ulClientIP;
	bool bIsCtrlCanalOpen;

	class CFtpServer *pFtpServer;
	bool SendReply( const char *pszReply, bool bNoNeedToAlloc = 0 );
	bool SendReply2( const char *pszList, ... );
};

class CFtpServer::CEnumFileInfo {
public:
	CEnumFileInfo() { memset( this, 0x0, sizeof( CEnumFileInfo ) ); }
	bool FindFirst( const char *pszPath );
	bool FindNext();
	bool FindClose();
	#ifdef WIN32
		long hFile;
		char pszTempPath[ MAX_PATH + 1 ];
		#ifdef __USE_FILE_OFFSET64
			struct _finddatai64_t c_file;
		#else
			struct _finddata_t c_file;
		#endif
	#else
		DIR *dp;
		struct stat st;
		struct dirent dir_entry;
	#endif
	char *pszName;
	char szDirPath[ MAX_PATH + 1 ];
	char szFullPath[ MAX_PATH + 1 ];
	#ifdef __USE_FILE_OFFSET64
		__int64 size;
	#else
		long size;
	#endif
	time_t mtime; // similar to st_mtime.
	unsigned short mode; // similar to st_mode.
};

#endif