#include "CFtpServer.h"
#include <string>
#include <map>

#include <node.h>
#include <uv.h>

using namespace v8;

CFtpServer* pFtpServer = new CFtpServer();
unsigned int usersCounter = 0;
std::map<unsigned int, CFtpServer::CUserEntry*> users;
Persistent<Function> cb;
uv_async_t global_async;

unsigned char StringToPrivileges(std::string priv) {
  unsigned char ucPriv = 0;
  for(std::string::iterator it = priv.begin(); it != priv.end(); ++it) {
    if('r' == *it || 'R' == *it)
      ucPriv |= CFtpServer::READFILE;
    else if('w' == *it || 'W' == *it)
      ucPriv |= CFtpServer::WRITEFILE;
    else if('l' == *it || 'L' == *it)
      ucPriv |= CFtpServer::LIST;
    else if('d' == *it || 'D' == *it)
      ucPriv |= CFtpServer::DELETEFILE;
    else if('c' == *it || 'C' == *it)
      ucPriv |= CFtpServer::CREATEDIR;
    else if('x' == *it || 'X' == *it)
      ucPriv |= CFtpServer::DELETEDIR;
  }
  return ucPriv;
}

std::string StringFromPrivileges(unsigned char ucPriv) {
  std::string priv = "";
  if((ucPriv & CFtpServer::READFILE) > 0)
    priv += "r";
  if((ucPriv & CFtpServer::WRITEFILE) > 0)
    priv += "w";
  if((ucPriv & CFtpServer::LIST) > 0)
    priv += "l";
  if((ucPriv & CFtpServer::DELETEFILE) > 0)
    priv += "d";
  if((ucPriv & CFtpServer::CREATEDIR) > 0)
    priv += "c";
  if((ucPriv & CFtpServer::DELETEDIR) > 0)
    priv += "x";
  return priv;
}

void CallbackHandler(uv_async_s* async, int error) {
  HandleScope scope;
  std::pair<std::string, std::string>* message = reinterpret_cast< std::pair< std::string, std::string >* >(async->data);
  if(!cb.IsEmpty()) {
    const unsigned argc = 2;
    Local<Value> argv[argc] = { Local<Value>::New(String::New(message->first.c_str())), Local<Value>::New(String::New(message->second.c_str())) };
    cb->Call(Context::GetCurrent()->Global(), argc, argv);
  }
  else {
    std::string ex = std::string("console.log('");
    ex += message->second.c_str();
    ex += ": ";
    ex += message->first.c_str();
    ex += "');";
    Handle<String> source = String::New(ex.c_str());
    Handle<Script> script = Script::Compile(source);
    script->Run();
  }
}

void OnServerEvent(int event) {
  std::string buf;
  switch(event) {

  case CFtpServer::START_LISTENING:
    buf = "Server is listening.";
    break;

  case CFtpServer::START_ACCEPTING:
    buf = "Server is accepting incoming connections.";
    break;

  case CFtpServer::STOP_LISTENING:
    buf = "Server stopped listening.";
    break;

  case CFtpServer::STOP_ACCEPTING:
    buf = "Server stopped accepting incoming connections.";
    break;

  case CFtpServer::MEM_ERROR:
    buf = "Warning, the CFtpServer class could not allocate memory.";
    break;

  case CFtpServer::THREAD_ERROR:
    buf = "Warning, the CFtpServer class could not create a thread.";
    break;

  }
  if(!buf.empty()) {
    global_async.data = new std::pair<std::string, std::string>(buf, "Server event");
    uv_async_send(&global_async);
  }
}

void OnUserEvent(int event, CFtpServer::CUserEntry *pUser, void *pArg) {
  std::string buf;
  switch(event) {

  case CFtpServer::NEW_USER:
    buf = "A new user \"";
    buf += pUser->GetLogin();
    buf += "\" has been created.";
    break;

  case CFtpServer::DELETE_USER:
    buf = "An User \"";
    buf += pUser->GetLogin();
    buf += "\" is being deleted.";
    break;

  }
  if(!buf.empty()) {
    global_async.data = new std::pair<std::string, std::string>(buf, "User event");
    uv_async_send(&global_async);
  }
}

void OnClientEvent(int event, CFtpServer::CClientEntry *pClient, void *pArg) {
  std::string buf;
  switch(event) {

  case CFtpServer::NEW_CLIENT:
    buf = "A new client has been created.\tClient IP: [";
    buf += inet_ntoa(*pClient->GetIP());
    buf += "]\tServer IP: [";
    buf += inet_ntoa(*pClient->GetServerIP());
    buf += "]";
    break;

  case CFtpServer::DELETE_CLIENT:
    buf = "A client is being deleted.\tClient IP: [";
    buf += inet_ntoa(*pClient->GetIP());
    buf += "]";
    break;

  case CFtpServer::CLIENT_AUTH:
    buf = "A client has logged-in as \"";
    buf += pClient->GetUser()->GetLogin();
    buf += "\".\tClient IP: [";
    buf += inet_ntoa(*pClient->GetIP());
    buf += "]";
    break;

  case CFtpServer::CLIENT_SOFTWARE:
    buf = "A client has proceed the CLNT FTP command: ";
    buf += (char*) pArg;
    buf += ". \tClient IP: [";
    buf += inet_ntoa(*pClient->GetIP());
    buf += "]";
    break;

  case CFtpServer::CLIENT_DISCONNECT:
    buf = "A client has disconnected.";
    buf += "\tClient IP: [";
    buf += inet_ntoa(*pClient->GetIP());
    buf += "]";
    break;

  case CFtpServer::CLIENT_UPLOAD:
    buf = "A client logged-on as \"";
    buf += pClient->GetUser()->GetLogin();
    buf += "\" is uploading a file: \"";
    buf += (char*) pArg;
    buf += "\". \tClient IP: [";
    buf += inet_ntoa(*pClient->GetIP());
    buf += "]";
    break;

  case CFtpServer::CLIENT_DOWNLOAD:
    buf = "A client logged-on as \"";
    buf += pClient->GetUser()->GetLogin();
    buf += "\" is downloading a file: \"";
    buf += (char*) pArg;
    buf += "\". \tClient IP: [";
    buf += inet_ntoa(*pClient->GetIP());
    buf += "]";
    break;

  case CFtpServer::CLIENT_LIST:
    buf = "A client logged-on as \"";
    buf += pClient->GetUser()->GetLogin();
    buf += "\" is listing a directory: \"";
    buf += (char*) pArg;
    buf += "\". \tClient IP: [";
    buf += inet_ntoa(*pClient->GetIP());
    buf += "]";
    break;

  case CFtpServer::CLIENT_CHANGE_DIR:
    buf = "A client logged-on as \"";
    buf += pClient->GetUser()->GetLogin();
    buf += "\" has changed its working directory:\tFull path: \"";
    buf += (char*) pArg;
    buf += "\". \tWorking directory: \"";
    buf += pClient->GetWorkingDirectory();
    buf += "\". \tClient IP: [";
    buf += inet_ntoa(*pClient->GetIP());
    buf += "]";
    break;

  case CFtpServer::RECVD_CMD_LINE:
    buf = "Received: ";
    buf += pClient->GetUser() ? pClient->GetUser()->GetLogin() : "(Not logged in)";
    buf += " > ";
    buf += (char*) pArg;
    buf += " [";
    buf += inet_ntoa(*pClient->GetIP());
    buf += "]";
    break;

  case CFtpServer::SEND_REPLY:
    buf = "Sent: ";
    buf += pClient->GetUser() ? pClient->GetUser()->GetLogin() : "(Not logged in)";
    buf+= " > ";
    buf += (char*) pArg;
    buf += " [";
    buf += inet_ntoa(*pClient->GetIP());
    buf += "]";
    break;

  case CFtpServer::TOO_MANY_PASS_TRIES:
    buf = "Too many pass tries.\tClient IP: [";
    buf += inet_ntoa(*pClient->GetIP());
    buf += "]";
    break;

  }
  if(!buf.empty()) {
    global_async.data = new std::pair<std::string, std::string>(buf, "Client event");
    uv_async_send(&global_async);
  }
}

Handle<Value> AddUser(const Arguments& args) {
  HandleScope scope;
  if(args.Length() < 3) {
    ThrowException(Exception::Error(String::New("Wrong number of arguments. ")));
    return scope.Close(Boolean::New(false));
  }
  if(!args[4]->IsUndefined() && !args[4]->IsUint32()) {
    ThrowException(Exception::TypeError(String::New("Wrong arguments [5]. ")));
    return scope.Close(Boolean::New(false));
  }
  unsigned char ucPriv = 0;
  if(!args[3]->IsUndefined())
    ucPriv = StringToPrivileges(std::string(*String::Utf8Value(args[3]->ToString())));
  unsigned int uNum = 0;
  if(!args[4]->IsUndefined())
    uNum = args[4]->Uint32Value();
  CFtpServer::CUserEntry* pUser = pFtpServer->AddUser(
    *String::Utf8Value(args[0]->ToString()), // login
    *String::Utf8Value(args[1]->ToString()), // password
    *String::Utf8Value(args[2]->ToString()) // directory
  );
  if(!pUser)
    return scope.Close(Boolean::New(false));
  pUser->SetMaxNumberOfClient(uNum);
  pUser->SetPrivileges(ucPriv);
  users[usersCounter++] = pUser;
  return scope.Close(Boolean::New(true));
}

Handle<Value> GetUsers(const Arguments& args) {
  HandleScope scope;
  Local<Array> ret = Array::New(users.size());
  unsigned int i = 0;
  for(std::map<unsigned int, CFtpServer::CUserEntry*>::iterator it = users.begin(); it != users.end(); ++it, ++i) {
    Local<Object> obj = Object::New();
    CFtpServer::CUserEntry* u = it->second;
    std::string priv = StringFromPrivileges(u->GetPrivileges());
    obj->Set(String::New("id"), Uint32::New(it->first));
    obj->Set(String::New("login"), String::New(u->GetLogin()));
    obj->Set(String::New("password"), String::New(u->GetPassword())); 
    obj->Set(String::New("startDirectory"), String::New(u->GetStartDirectory())); 
    obj->Set(String::New("privileges"), String::New(priv.c_str())); 
    obj->Set(String::New("maxClient"), Uint32::New(u->GetMaxClient())); 
    ret->Set(i, obj);
  }
  return scope.Close(ret);
}

Handle<Value> GetUsersCount(const Arguments& args) {
  HandleScope scope;
  return scope.Close(Uint32::New(users.size()));
}

Handle<Value> GetUser(const Arguments& args) {
  HandleScope scope;
  if(args.Length() < 1) {
    ThrowException(Exception::Error(String::New("Wrong number of arguments. ")));
    return scope.Close(Boolean::New(false));
  }
  if(!args[0]->IsUndefined() && !args[0]->IsUint32()) {
    ThrowException(Exception::TypeError(String::New("Wrong arguments [1]. ")));
    return scope.Close(Boolean::New(false));
  }
  unsigned int key = args[0]->Uint32Value();
  if(!users[key]) {
    ThrowException(Exception::Error(String::New("Uncorrect user id. ")));
    return scope.Close(Boolean::New(false));
  }
  Local<Object> ret = Object::New();
  CFtpServer::CUserEntry* u = users[key];
  std::string priv = StringFromPrivileges(u->GetPrivileges());
  ret->Set(String::New("id"), Uint32::New(key));
  ret->Set(String::New("login"), String::New(u->GetLogin()));
  ret->Set(String::New("password"), String::New(u->GetPassword())); 
  ret->Set(String::New("startDirectory"), String::New(u->GetStartDirectory())); 
  ret->Set(String::New("privileges"), String::New(priv.c_str())); 
  ret->Set(String::New("maxClient"), Uint32::New(u->GetMaxClient())); 
  return scope.Close(ret);
}

Handle<Value> RemoveUser(const Arguments& args) {
  HandleScope scope;
  if(args.Length() < 1) {
    ThrowException(Exception::Error(String::New("Wrong number of arguments. ")));
    return scope.Close(Boolean::New(false));
  }
  if(!args[0]->IsUndefined() && !args[0]->IsUint32()) {
    ThrowException(Exception::TypeError(String::New("Wrong arguments [1]. ")));
    return scope.Close(Boolean::New(false));
  }
  unsigned int key = args[0]->Uint32Value();
  if(!users[key]) {
    ThrowException(Exception::Error(String::New("Uncorrect user id. ")));
    return scope.Close(Boolean::New(false));
  }
  if(!pFtpServer->DeleteUser(users[key]))
    return scope.Close(Boolean::New(false));
  users.erase(key);
  return scope.Close(Boolean::New(true));
}

Handle<Value> SetUserLogin(const Arguments& args) {
  HandleScope scope;
  if(args.Length() < 2) {
    ThrowException(Exception::Error(String::New("Wrong number of arguments. ")));
    return scope.Close(Boolean::New(false));
  }
  if(!args[0]->IsUndefined() && !args[0]->IsUint32()) {
    ThrowException(Exception::TypeError(String::New("Wrong arguments [1]. ")));
    return scope.Close(Boolean::New(false));
  }
  unsigned int key = args[0]->Uint32Value();
  if(!users[key]) {
    ThrowException(Exception::Error(String::New("Uncorrect user id. ")));
    return scope.Close(Boolean::New(false));
  }
  users[key]->SetLogin(*String::Utf8Value(args[1]->ToString()));
  return scope.Close(Boolean::New(true));
}

Handle<Value> SetUserPassword(const Arguments& args) {
  HandleScope scope;
  if(args.Length() < 2) {
    ThrowException(Exception::Error(String::New("Wrong number of arguments. ")));
    return scope.Close(Boolean::New(false));
  }
  if(!args[0]->IsUndefined() && !args[0]->IsUint32()) {
    ThrowException(Exception::TypeError(String::New("Wrong arguments [1]. ")));
    return scope.Close(Boolean::New(false));
  }
  unsigned int key = args[0]->Uint32Value();
  if(!users[key]) {
    ThrowException(Exception::Error(String::New("Uncorrect user id. ")));
    return scope.Close(Boolean::New(false));
  }
  users[key]->SetPassword(*String::Utf8Value(args[1]->ToString()));
  return scope.Close(Boolean::New(true));
}

Handle<Value> SetUserStartDirectory(const Arguments& args) {
  HandleScope scope;
  if(args.Length() < 2) {
    ThrowException(Exception::Error(String::New("Wrong number of arguments. ")));
    return scope.Close(Boolean::New(false));
  }
  if(!args[0]->IsUndefined() && !args[0]->IsUint32()) {
    ThrowException(Exception::TypeError(String::New("Wrong arguments [1]. ")));
    return scope.Close(Boolean::New(false));
  }
  unsigned int key = args[0]->Uint32Value();
  if(!users[key]) {
    ThrowException(Exception::Error(String::New("Uncorrect user id. ")));
    return scope.Close(Boolean::New(false));
  }
  users[key]->SetStartDirectory(*String::Utf8Value(args[1]->ToString()));
  return scope.Close(Boolean::New(true));
}

Handle<Value> SetUserPrivileges(const Arguments& args) {
  HandleScope scope;
  if(args.Length() < 2) {
    ThrowException(Exception::Error(String::New("Wrong number of arguments. ")));
    return scope.Close(Boolean::New(false));
  }
  if(!args[0]->IsUndefined() && !args[0]->IsUint32()) {
    ThrowException(Exception::TypeError(String::New("Wrong arguments [1]. ")));
    return scope.Close(Boolean::New(false));
  }
  unsigned int key = args[0]->Uint32Value();
  if(!users[key]) {
    ThrowException(Exception::Error(String::New("Uncorrect user id. ")));
    return scope.Close(Boolean::New(false));
  }
  unsigned char ucPriv = StringToPrivileges(std::string(*String::Utf8Value(args[1]->ToString())));
  if(!users[key]->SetPrivileges(ucPriv))
    return scope.Close(Boolean::New(false));
  return scope.Close(Boolean::New(true));
}

Handle<Value> SetUserMaxNumberOfClient(const Arguments& args) {
  HandleScope scope;
  if(args.Length() < 2) {
    ThrowException(Exception::Error(String::New("Wrong number of arguments. ")));
    return scope.Close(Boolean::New(false));
  }
  if(!args[0]->IsUndefined() && !args[0]->IsUint32()) {
    ThrowException(Exception::TypeError(String::New("Wrong arguments [1]. ")));
    return scope.Close(Boolean::New(false));
  }
  if(!args[1]->IsUndefined() && !args[1]->IsUint32()) {
    ThrowException(Exception::TypeError(String::New("Wrong arguments [2]. ")));
    return scope.Close(Boolean::New(false));
  }
  unsigned int key = args[0]->Uint32Value();
  if(!users[key]) {
    ThrowException(Exception::Error(String::New("Uncorrect user id. ")));
    return scope.Close(Boolean::New(false));
  }
  users[key]->SetMaxNumberOfClient(args[1]->Uint32Value());
  return scope.Close(Boolean::New(true));
}

Handle<Value> Start(const Arguments& args) {
  HandleScope scope;
  unsigned short int port = 21;
  if(!args[0]->IsUndefined())
    port = args[0]->Int32Value();
  bool WantListenonTCPLoopback = false;
  if(!args[1]->IsUndefined())
    WantListenonTCPLoopback = args[1]->BooleanValue();
  if(users.empty()) {
    ThrowException(Exception::Error(String::New("You must add user before. ")));
    return scope.Close(Boolean::New(false));
  }
  if(!pFtpServer->StartListening(WantListenonTCPLoopback ? inet_addr("127.0.0.1") : INADDR_ANY, port)
  ) {
    ThrowException(Exception::Error(String::New("Unable to listen. ")));
    return scope.Close(Boolean::New(false));
  }
  if(!pFtpServer->StartAccepting()) {
    ThrowException(Exception::Error(String::New("Unable to accepting. ")));
    return scope.Close(Boolean::New(false));
  }
  return scope.Close(Boolean::New(true));
}

Handle<Value> Stop(const Arguments& args) {
  HandleScope scope;
  if(pFtpServer->StopListening() && pFtpServer->StopAccepting())
    return scope.Close(Boolean::New(true));
  return scope.Close(Boolean::New(false));
}

Handle<Value> IsRunning(const Arguments& args) {
  HandleScope scope;
  if(pFtpServer->IsListening() && pFtpServer->IsAccepting())
    return scope.Close(Boolean::New(true));
  return scope.Close(Boolean::New(false));
}

Handle<Value> SetCallback(const Arguments& args) {
  HandleScope scope;
  pFtpServer->SetServerCallback(OnServerEvent);
  pFtpServer->SetUserCallback(OnUserEvent);
  pFtpServer->SetClientCallback(OnClientEvent);
  if(!args[0]->IsUndefined())
    cb = Persistent<Function>::New(Local<Function>::Cast(args[0]));
  return scope.Close(Undefined());
}

void Init(Handle<Object> exports) {

  uv_async_init(uv_default_loop(), &global_async, CallbackHandler);

  exports->Set(String::NewSymbol("addUser"), FunctionTemplate::New(AddUser)->GetFunction());
  exports->Set(String::NewSymbol("getUsers"), FunctionTemplate::New(GetUsers)->GetFunction());
  exports->Set(String::NewSymbol("getUsersCount"), FunctionTemplate::New(GetUsersCount)->GetFunction());
  exports->Set(String::NewSymbol("getUser"), FunctionTemplate::New(GetUser)->GetFunction());
  exports->Set(String::NewSymbol("removeUser"), FunctionTemplate::New(RemoveUser)->GetFunction());
  exports->Set(String::NewSymbol("setUserLogin"), FunctionTemplate::New(SetUserLogin)->GetFunction());
  exports->Set(String::NewSymbol("setUserPassword"), FunctionTemplate::New(SetUserPassword)->GetFunction());
  exports->Set(String::NewSymbol("setUserStartDirectory"), FunctionTemplate::New(SetUserStartDirectory)->GetFunction());
  exports->Set(String::NewSymbol("setUserPrivileges"), FunctionTemplate::New(SetUserPrivileges)->GetFunction());
  exports->Set(String::NewSymbol("setUserMaxNumberOfClient"), FunctionTemplate::New(SetUserMaxNumberOfClient)->GetFunction());
  exports->Set(String::NewSymbol("start"), FunctionTemplate::New(Start)->GetFunction());
  exports->Set(String::NewSymbol("stop"), FunctionTemplate::New(Stop)->GetFunction());
  exports->Set(String::NewSymbol("isRunning"), FunctionTemplate::New(IsRunning)->GetFunction());
  exports->Set(String::NewSymbol("setCallback"), FunctionTemplate::New(SetCallback)->GetFunction());

}

NODE_MODULE(ftpd, Init)